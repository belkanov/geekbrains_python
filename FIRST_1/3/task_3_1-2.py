"""
1.  Написать функцию num_translate(), переводящую числительные от 0 до 10 c английского на русский язык. Например:
     num_translate("one")
    "один"
     num_translate("eight")
    "восемь"
    Если перевод сделать невозможно, вернуть None. Подумайте, как и где лучше хранить информацию, необходимую для перевода: какой тип данных выбрать, в теле функции или снаружи.

2.  *(вместо задачи 1) Доработать предыдущую функцию в num_translate_adv(): реализовать корректную работу с числительными, начинающимися с заглавной буквы - результат тоже должен быть с заглавной. Например:
    num_translate_adv("One")
    "Один"
    num_translate_adv("two")
    "два"
"""

# если бы не вторая функция, я бы словарь сделал внутри первой функции (я так сделал в 5ом задании),
# т.к. данные специфичны только для нее.
# Но я не знаю насколько это (словарь внутри функции) правильный подход в том плане, что если код большой,
# то после вызова функции может пройти продолжительное время перед ее повторным вызовом и к этому моменту сработает сборщик мусора (а может и не сработает..).
# Тогда при повторном вызове снова будет инициализация словаря.. и так может быть много раз.
# Может тут нет верного ответа и правильный вариант подскажет профилирование конкретного кода.
#
# Просьба прокомментировать этот момент.
num_alpha = {
    'zero': 'ноль',
    'one': 'один',
    'two': 'два',
    'three': 'три',
    'four': 'четыре',
    'five': 'пять',
    'six': 'шесть',
    'seven': 'семь',
    'eight': 'восемь',
    'nine': 'девять',
    'ten': 'десять'
}


def num_translate(num_en):
    return num_alpha.get(num_en)


# чуть больше наворотов чем требовалось, но заданию соответствует
def num_translate_adv(num_en):
    # сделал бы (x.isupper() for x in num_en), но мы генераторы вроде еще не трогали
    # + map рабоатет чуток быстрее, но запись через генератор мне больше нравится
    upper_idx = tuple(map(str.isupper, num_en))

    # тут наверное стоит добавить немного комментов =)
    #
    # для начала всю эту кашу скорее всего будет удобней читать, если разбить на переменные/условия/...
    # я себе просто поставил задачу написать в одну строку
    #
    # в кратце - преобразуем регистр в соответсвии с регистром каждой буквы (upper_idx) англ. слова,
    # если кол-во букв в num_en меньше чем в ответе - оставшиеся в ответе останутся строчными
    # ну или если быть точнее - теми, что указаны в словаре
    #
    # ко всему прочему узнал, что распаковка кортежей в параметры функции недопустима (PEP 3113) =( поэтому индексы
    return ''.join(map(lambda tpl: tpl[1].upper() if (upper_idx[tpl[0]] if tpl[0] < len(upper_idx) else False) else tpl[1], enumerate(num_alpha.get(num_en.lower()))))


number = 'thrEe'
print(f'{number} - {num_translate(number)}')
number = 'four'
print(f'{number} - {num_translate(number)}')

print('-----')

number = 'foUr'
print(f'{number} - {num_translate_adv(number)}')
number = 'Five'
print(f'{number} - {num_translate_adv(number)}')
