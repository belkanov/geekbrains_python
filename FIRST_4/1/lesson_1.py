from functools import reduce
from string import ascii_lowercase
from datetime import datetime
from time import sleep


def inpt(text, inpt_str):
    """
    на случай если появится желание проверить и вводить даные руками
    сделайте is_input_enable = True

    в остальных случаях будем работать с заготовленной строкой inpt_str

    просто для удобства)
    """

    is_input_enable = False
    if is_input_enable:
        rslt = input(text)
    else:
        rslt = inpt_str
    return rslt.split()


def part_1(x):
    print('--- # 1. Найти сумму и произведение цифр трехзначного числа, которое вводит пользователь.')
    # здесь и далее считаем пользователя адекватным и не проверям ввод
    n = inpt('Введите трехзначное число', x)[0]
    print(f'Сумма цифр числа {n} = {reduce(lambda a, b: int(a) + int(b), n)}')
    print(f'Произведение цифр числа {n} = {reduce(lambda a, b: int(a) * int(b), n)}')
    print()


def part_2():
    print('--- # 2. Выполнить логические побитовые операции «И», «ИЛИ» и др. над числами 5 и 6. Выполнить над числом 5 побитовый сдвиг вправо и влево на два знака. Объяснить полученный результат.')
    # я тут не увидел никаких алгоритмов, просто работа по правилам булевой алгебры, никаких велосипедов
    print(f'5 AND 6: {5 & 6}')  # 101 & 110 = 100 (4)
    print(f'5 OR 6 : {5 | 6}')  # 101 | 110 = 111 (7)
    print(f'5 XOR 6: {5 ^ 6}')  # 101 ^ 110 = 011 (3)
    print(f'~5     : {~5}')  # инверсия знака, -1: ~101 = -110 (-6)
    print(f'5 >> 2 : {5 >> 2}')  # целочисленное деление на 2 два раза: 5 // 2 // 2 = 1
    print(f'5 << 2 : {5 << 2}')  # умножение на 2 два раза: 5 * 2 * 2 = 20
    print()


def part_3(x1y1, x2y2):
    print('--- # 3. По введенным пользователем координатам двух точек вывести уравнение прямой вида y=kx+b, проходящей через эти точки.')

    x1, y1 = map(int, inpt('Введите координаты первой точки: ', x1y1))
    x2, y2 = map(int, inpt('Введите координаты второй точки: ', x2y2))

    k = (y1 - y2) / (x1 - x2)
    b = y2 - k * x2
    print(f'Для координат {x1, y1}{x2, y2} уравнение: y = {k:-.3g}*x{b:+.3g}')  # y = 0.75*x-0.25 (для 3 2 -1 -1)
    print()


def part_4():
    print('--- # 4. Написать программу, которая генерирует сулчайные значения в указанных пользователем границах')
    # 4. Написать программу, которая генерирует в указанных пользователем границах:
    #    случайное целое число;
    #    случайное вещественное число;
    #    случайный символ.
    #    Для каждого из трех случаев пользователь задает свои границы диапазона.
    #    Например, если надо получить случайный символ от 'a' до 'f', то вводятся эти символы.
    #    Программа должна вывести на экран любой символ алфавита от 'a' до 'f' включительно.

    # для генерации одного числа по запросу пользователя такое ± прокатит.
    # для генерации в моменте 1000 шт рандомных чисел - надо думать что-то другое
    # т.к. я немного потестил и, например, при созаднии [get_rndm() for _ in range(1000)] уникальных значений получается всего 20шт,
    # на более быстрых машинах и того меньше будет
    #
    # например, можно на основе полученного генерить новый рандом, но я не стал углубляться

    def get_rndm():
        """
        берем дату в формате timestamp. целую часть и мс разбиваем на десятки
        потом делим эти десятки каждый на каждый, суммируем, и переводим в диапазон  (0, 1)
        """

        def split_float(num, n=2):
            # 123456.7891 -> [56, 34, 12], [78, 91, ...]
            delimiter = 10 ** n
            int_part = int(num)  # 123456.7891 -> 123456
            frac_part = num - int_part  # 123456.7891 -> 0.7891
            int_lst = []
            while int_part != 0:  # 123456 -> [56, 34, 12]
                int_lst.append(int_part % delimiter)  # 123456 % 100 = 56 -> [56,]; 1234 % 100 = 34 -> [56, 34]; ...
                int_part = int(int_part / delimiter)  # 123456 / 100 = 1234.56 -> 1234; 1234 / 100 = 12.34 -> 12; ...
            frac_lst = []
            # ввиду особенностей представления float решил сделать равное кол-во элементов,
            # иначе тут было бы только 3 элемента, т.к. мс - 6 цифр
            for _ in range(len(int_lst)):  # 0.7891 -> [78, 91, ...]
                frac_part *= delimiter  # 0.7891 * 100 = 78.91; 0.91 * 100 = 91.???; ...
                int_frac = int(frac_part)  # 78.91 -> 78; 91.??? -> 91; ...
                frac_lst.append(int_frac or 1)  # если вдруг 0, чтоб потом небыло проблем с расчетами; [78]; [78, 91]; ...
                frac_part -= int_frac  # 78.91 - 78 = 0.91; 91.??? - 91 = 0.???; ...
            return int_lst, frac_lst

        def split_by_chunk(lst, n=2):
            # '123456' -> [['12'], ['34'], ['56']]  # n=2 - кол-во элемнтов в каждом списке
            return [lst[i:i + n] for i in range(0, len(lst), n)]

        dt = datetime.now().timestamp()
        # сначала делал через преобразование в строки и работой через сплит и списки,
        # потом решил через математику сделать
        # хотя в итоге через строки намного короче =)
        # ts_lst = list(map(int, split_by_chunk(str(int(dt.timestamp())))))
        # ms_lst = list(map(int, split_by_chunk(f'{dt.microsecond:06d}')))

        ts_lst, ms_lst = split_float(dt)
        rslt = sum((ms / ts for ts in ts_lst for ms in ms_lst))
        rslt = float(f'0.{str(rslt).replace(".", "")}')
        return rslt

    def float_rndm(start=-100, stop=100):
        def get_float(num, min, max):
            # num: 0.2934   min-max: 30-50
            rslt = num
            while rslt < max:
                rslt *= 10  # 0.2934 * 10 * 10 * ... -> 293.4
            while rslt > max:
                rslt -= (max-min)  # 293.4 - 20 - 20 - ...  -> 33.4
            return rslt

        # для комментов будет два варианта:
        # (-30, 100)
        # (20, 50)
        rndm = get_rndm()
        if start < 0:  # если у нас диапазон содержит отрицательную границу (-30, 100)
            rndm *= 100
            sign_plus = int(rndm) >= 50  # используем первые цифру дробной части для определения знака рандома
            rndm -= int(rndm)
            if sign_plus:
                rslt = get_float(rndm, 0, stop)  # если нам надо сделать положительное, то нужен диапазон (0, 100)
            else:
                rslt = get_float(rndm, 0, -start)  # если отрицательное, то (0, -(-30)) -> (0, 30)
                rslt = -rslt
        else:  # если отрцательной границы нет (20, 50)
            rslt = get_float(rndm, start, stop)  # то работаем без ухирщений (20, 50)
        return rslt

    def int_rndm(start=-100, stop=100):
        return int(float_rndm(start, stop))

    int_range = [*map(int, inpt('Введите диапазон целых чисел для генерации целого числа', '-1000 1000'))]
    print(f'Случайное целое число для ({int_range[0]}, {int_range[1]}): {int_rndm(int_range[0], int_range[1])}')
    sleep(0.1)  # без него значения будут совпадать в рамках одного запуска. причины выше.
    float_range = [*map(int, inpt('Введите диапазон целых чисел для генерации вещественного числа', '-1000 1000'))]
    print(f'Случайное вещественное число для ({float_range[0]}, {float_range[1]}): {float_rndm(float_range[0], float_range[1])}')
    sleep(0.1)
    az_range = inpt('Введмите буквенный (англ. симвл.) диапазон для генерации символа', 'a i')
    print(f'Случайный символ из диапазона {az_range[0]}-{az_range[1]}: {ascii_lowercase[int_rndm(ascii_lowercase.find(az_range[0]), ascii_lowercase.find(az_range[1]))]}')
    print()


def part_5(letters):
    print('--- # 5. Пользователь вводит две буквы. Определить, на каких местах алфавита они стоят и сколько между ними находится букв.')

    # раз мы тут пишем велосипеды то вот так. по нормальному конечно можно через str.find()
    def find_letter(l):
        rslt = None
        # т.к. речь про алфавит, а не про ascii-коды, то регистр не важен и будем работать в нижнем
        for i in range(len(ascii_lowercase)):
            if l == ascii_lowercase[i]:
                rslt = i
                break
        return rslt

    l1, l2 = inpt('Введите две буквы английского алфавита:', letters)
    idx_1 = find_letter(l1.lower())
    idx_2 = find_letter(l2.lower())
    rng = abs(idx_2 - idx_1) - 1
    # я понимаю, что тут надо бы склонение "букв" добавить, как раз из вебинара, но я не стал =)
    print(f'Буква {l1} находится на {idx_1 + 1} месте; буква {l2} находится на {idx_2 + 1} месте; {"они соседи" if rng == 0 else "между ними " + str(rng) + " букв"}')
    print()


def part_6(letter_idx):
    print('--- # 6. Пользователь вводит номер буквы в алфавите. Определить, какая это буква.')

    # я вот не уверен, что именно такое решение ожидается.
    # возможно надо было просто обратиться по ascii_lowercase[l_idx-1] (раз у нас алфавит, то список букв отсортирован)
    l_idx = int(inpt('Введите номер буквы в английском алфавите:', letter_idx)[0])
    for i in range(1, len(ascii_lowercase) + 1):
        if l_idx == i:
            print(f'{l_idx} буква - {ascii_lowercase[i-1]}')
            break
    print()


def part_7(abc):
    print('--- # 7. По длинам трех отрезков, введенных пользователем, определить возможность существования треугольника, составленного из этих отрезков.')
    #    Если такой треугольник существует, то определить, является ли он разносторонним, равнобедренным или равносторонним.

    a, b, c = map(int, inpt('Введите длины трех отрезков', abc))

    if a + b <= c or a + c <= b or b + c <= a:
        rslt = 'не существует'
    elif a != b and a != c and b != c:
        rslt = 'разносторонний'
    elif a == b == c:
        rslt = 'равносторонний'
    else:
        rslt = 'равнобедренный'
    print(f'Для отрезков {a, b, c} треугольник: {rslt}')
    print()


def part_8(yr):
    print('--- # 8. Определить, является ли год, который ввел пользователем, високосным или невисокосным.')

    y = int(inpt('Введите год', yr)[0])

    if y % 4 != 0 or (y % 100 == 0 and y % 400 != 0):
        print(f'{y} год - обычный')
    else:
        print(f'{y} год - високосный')
    print()


def part_9(xyz):
    print('--- # 9. Вводятся три разных числа. Найти, какое из них является средним (больше одного, но меньше другого).')

    # не сработает для одинаковых чисел, но как я писал в задании 1 - считаем пользователя адекватным
    # значит на ввод ожидаем разные числа
    x, y, z = map(int, inpt('Введите три числа:', xyz))
    if x < y < z:
        rslt = y
    elif y < z < x:
        rslt = z
    else:
        rslt = x
    print(f'Среди чисел {x, y, z} средним числом является {rslt}')


def main():
    part_1('555')
    part_2()
    part_3('3 2', '-1 -1')
    part_4()
    part_5('A b')
    part_6('12')
    part_7('5 6 9')
    part_8('2016')
    part_9('7 -1 9')


if __name__ == '__main__':
    main()
    # dt = datetime.now()
    # print(dt)
    # ms = f'{235:06d}'
    # print(ms)
