from random import random, randint

N = 20


def part_1():
    print('# 1. Отсортируйте по убыванию методом "пузырька" одномерный целочисленный массив, заданный случайными числами на промежутке [-100; 100).')
    #    Выведите на экран исходный и отсортированный массивы. Сортировка должна быть реализована в виде функции.
    #    По возможности доработайте алгоритм (сделайте его умнее).

    arr = [randint(-100, 100) for _ in range(N)]
    print(f'{arr = }')
    for i in range(-2, -len(arr) - 1, -1):  # идем с предпоследнего элемента в начало
        j = i
        while j < -1:
            if arr[j] < arr[j + 1]:  # если текущий элемент меньше следующего - меняем их
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                j += 1  # и смотрим дальше
            else:
                break  # иначе переходим на следующий шаг
    print(f'{arr = }\n')


def part_2():
    print('# 2. Отсортируйте по возрастанию методом слияния одномерный вещественный массив, заданный случайными числами на промежутке [0; 50).')

    #    Выведите на экран исходный и отсортированный массивы.

    def merge_sort(a):
        if len(a) in (0, 1):
            return a
        l, r = merge_sort(a[:len(a) // 2]), merge_sort(a[len(a) // 2:])
        l_idx = r_idx = 0
        rslt = []
        while l_idx < len(l) or r_idx < len(r):
            if r_idx == len(r):  # если из правой части мы все взяли - работаем только с левой
                rslt.append(l[l_idx])
                l_idx += 1
            elif l_idx == len(l):  # аналогично для левой
                rslt.append(r[r_idx])
                r_idx += 1
            elif l[l_idx] < r[r_idx]:  # если элемент из левой меньше
                rslt.append(l[l_idx])
                l_idx += 1
            else:  # r[r_idx] < l[l_idx] или равны, если числа целые
                rslt.append(r[r_idx])
                r_idx += 1
        return rslt

    arr = [round(random() * 50, 2) for _ in range(N)]  # округление просто для наглядности
    print(f'{arr = }')
    print(f'arr = {merge_sort(arr)}\n')


def part_3():
    print('# 3. Массив размером 2m + 1, где m – натуральное число, заполнен случайным образом. Найдите в массиве медиану.')
    #    Медианой называется элемент ряда, делящий его на две равные части: в одной находятся элементы, которые не меньше медианы, в другой – не больше медианы.
    #    Задачу можно решить без сортировки исходного массива. Но если это слишком сложно, то используйте метод сортировки, который не рассматривался на уроках

    # пример когда медиана (73) дублирована
    # в этом случае левая часть будет больше на 1 значение. Не считаю это критичным - нам по ТЗ с этими частями делать нчиего не надо
    # arr = [46, 56, 88, 73, 1, 87, 95, 70, 99, 91, 91, 100, 95, 9, 1, 25, 73, 48, 100, 33, 73]
    arr = [randint(0, 100) for _ in range(2 * N // 2 + 1)]  # // 2 -- чтоб массив был примерно такой же как остальные
    print(f'{arr = }')
    m = None
    l = []
    r = []
    for i in range(len(arr)):
        # была еще мысль сделать за один проход, но там как-то замароченно искалась медиана, решил что лучше более читаемый код
        m = arr[i]
        l.clear()
        r.clear()
        # распихиваем остальные значения на две части. Остановимся, когда эти части будут равны.
        for j in range(len(arr)):
            if j == i:  # пропускаем само себя
                continue
            # python 3.8+
            elif (t := arr[j]) <= m:
                l.append(t)
            else:
                r.append(t)
        if (t := len(l) - len(r)) == 0 or arr.count(m) > 1 and t == 1:  # второе условие на случай если медиана будет дублирована
            break  # нашли
    print(f'({len(l)}){sorted(l)} {m} {sorted(r)}({len(r)})')  # соритровка для наглядности


def main():
    part_1()
    part_2()
    part_3()


if __name__ == '__main__':
    main()
